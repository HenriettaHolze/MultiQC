""" MultiQC module to parse output from UMI-tools """


import logging
import re
from collections import OrderedDict

from multiqc import config
from multiqc.modules.base_module import BaseMultiqcModule
from multiqc.plots import bargraph, beeswarm

# Initialise the logger
log = logging.getLogger(__name__)


class MultiqcModule(BaseMultiqcModule):
    """
    umitools module class, parses whitelist logs
    """

    def __init__(self):
        # Initialise the parent object
        super(MultiqcModule, self).__init__(
            name="UMI-tools whitelist",
            anchor="umitools_whitelist",
            href="https://github.com/CGATOxford/UMI-tools",
            info="contains tools for dealing with Unique Molecular Identifiers (UMIs)/(RMTs) and scRNA-Seq barcodes.",
            doi="10.1101/gr.209601.116",
        )

        # Find and load any umitools log files
        self.umitools_data = dict()
        for f in self.find_log_files("umitools_whitelist"):
            # Parse the log file for sample name and statistics
            input_fname, data = self.parse_logs(f)
            if data and len(data) > 1:
                # Clean the sample name
                f["s_name"] = self.clean_s_name(input_fname, f)
                # Log a warning if the log file matches an existing sample name
                if f["s_name"] in self.umitools_data:
                    log.debug("Duplicate sample name found! Overwriting: {}".format(f["s_name"]))
                # Store the data in the overall data dictionary
                self.umitools_data[f["s_name"]] = data
                # Add the log file information to the multiqc_sources.txt
                self.add_data_source(f)

        # Check the log files against the user supplied list of samples to ignore
        self.umitools_data = self.ignore_samples(self.umitools_data)

        # If no files are found, raise an exception
        if len(self.umitools_data) == 0:
            raise UserWarning

        # Log the number of reports found
        log.info("Found {} reports".format(len(self.umitools_data)))

        # Write parsed report data to a file
        self.write_data_file(self.umitools_data, "multiqc_umitools_whitelist")

        # # write data to the general statistics table
        # self.umitools_general_stats_table()

        # add a section with proportion of identified cell barcodes that passed threshold
        self.add_section(
            name="Whitelisted cell barcodes",
            anchor="umitools_whitelist_cbs",
            description="This plot shows the number of whitelisted cell barcodes.",
            plot=self.umitools_whitelist_cbs_barplot(),
        )


    def parse_logs(self, f):
        # Check this is a whitelist log
        if "# output generated by whitelist" not in f["f"]:
            log.debug(f"Skipping as not a whitelist log: {f['fn']}")
            return None, None

        # Get the s_name from the input file if possible
        # stdin : <_io.TextIOWrapper name='M18-39155_T1.Aligned.sortedByCoord.out.bam' mode='r' encoding='UTF-8'>
        s_name_re = r"stdin\s+:\s+<_io\.TextIOWrapper name='([^\']+)'"
        s_name_match = re.search(s_name_re, f["f"])
        if s_name_match:
            s_name = s_name_match.group(1)
        else:
            s_name = f["s_name"]

        # Initialise a dictionary to hold the data from this log file
        data = {}

        # Search for values using regular expressions
        regexes = {
            "total_cbs": r"INFO Found (\d+) unique cell barcodes",
            "selected_cbs": r"INFO Top (\d+) cell barcodes passed the selected threshold",
        }
        for key, regex in regexes.items():
            re_matches = re.search(regex, f["f"])
            if re_matches:
                data[key] = float(re_matches.group(1))

        # calculate a few simple supplementary stats
        try:
            data["filtered_cbs"] = data["total_cbs"] - data["selected_cbs"]
        except (KeyError, ZeroDivisionError):
            pass

        return s_name, data


    def umitools_whitelist_cbs_barplot(self):
        """Bar plot showing proportion of cell barcodes that pass threshold"""

        cats = OrderedDict()
        cats["selected_cbs"] = {"color": "#7fc97f", "name": "Whitelisted cell barcodes"}
        cats["filtered_cbs"] = {"color": "#fdc086", "name": "Filtered cell barcodes"}

        # Config for the plot
        config = {
            "id": "umitools_whitelist_cbs_barplot",
            "title": "UMI-tools: Whitelisted Cell Barcodes",
            "ylab": "# Cell Barcodes",
            "cpswitch_counts_label": "Number of Cell Barcodes",
        }

        return bargraph.plot(self.umitools_data, cats, config)
